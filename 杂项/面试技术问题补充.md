# 面试技术问题补充

## MySQL和Redis的范围查询分别如何实现，有什么区别？

### MySQL的范围查询

MySQL 作为关系型数据库，天然支持范围查询。常用的SQL语法如下：

```sql
SELECT * FROM table WHERE column BETWEEN value1 AND value2;
SELECT * FROM table WHERE column >= value1 AND column <= value2;
SELECT * FROM table WHERE column > value1 AND column < value2;
```

**特点：**

- 支持多条件复合范围查询。
- 可以利用索引（如BTree索引）加速范围查询。
- 查询结果有排序、分页等功能。
- 适合数据量大、复杂条件的检索。

### Redis的范围查询

- Sorted Set (zset) 范围查询

```shell
ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]
```

- List 范围查询(按下标)

```shell
LRANGE key start stop
```
**特点：**

- 依赖数据结构（如zset的分数score）。
- 查询效率高（内存操作，适合小范围、实时性高的场景）。
- 不支持复杂多条件的范围查询。
- 结果通常无分页/排序（zset有序，list有序）。
- 适合排行榜、消息队列、缓存等实时性需求高的场景。

**总结：**

| 项目     | MySQL                          | Redis（主要指zset）      |
| -------- | ------------------------------ | ------------------------ |
| 数据结构 | 行、表、字段（关系型）         | 键、值、集合（非关系型） |
| 索引支持 | 支持多种索引（BTree等）        | zset分数为索引           |
| 查询能力 | 复杂多条件，支持排序、分页     | 单条件、按score或排序    |
| 查询效率 | 取决于索引和数据量（磁盘为主） | 高效（内存操作）         |
| 适合场景 | 复杂业务查询、数据分析         | 排行榜、缓存、实时查询   |
| 数据结构 | B+树                           | 跳表                     |

## 如何实现一个RPC框架

### RPC框架是什么？

RPC框架的核心作用是：

- 屏蔽网络通信细节，简化分布式系统开发。
- 提供透明的远程过程调用能力。
- 实现客户端和服务器之间的序列化、传输、反序列化、调用和响应返回等流程。

常见的RPC框架有：`gRPC`、`Dubbo`、`Thrift`、`Hessian`等。

### 如何实现一个RPC框架

通常，一个完整的 RPC 框架包含以下几个核心部分：

- 服务端（Server）

    实际提供服务的业务实现方，监听并处理来自客户端的远程调用请求

- 服务桩（Server Stub）

    服务端的代理对象，负责将具体的业务服务包装成可以通过网络传输的数据格式（如序列化），并反序列化客户端传来的调用参数。
    
- 客户端（Client）

    发起远程服务调用请求的应用方。

- 客户桩（Client Stub/Proxy）

    客户端的代理对象，封装了网络通信细节，负责将本地方法调用转化为网络请求，再把远程返回值转换为本地对象返回。

- 通信模块（Transport Layer）

    具体负责网络间数据传输，如基于TCP/HTTP等的请求发送与响应接收。

- 序列化/反序列化（Serialization/Deserialization）

    负责将方法调用的参数、返回值等对象转化为可在网络上传输的二进制或文本格式，以及反向过程。

- 注册中心（可选，Registry）

    用于服务注册与发现，客户端可以动态获取服务端的可用地址。

- 协议层（Protocol Layer）

    规定数据包的格式、编码方式、请求响应的组织结构等。

图示结构：

```
Client --- Client Stub --- [网络通信] --- Server Stub --- Server
```

## Java与GO语言在各方面有什么差别？选型时如何考虑选择Java还是GO?

| 方面     | Java                           | Go (Golang)                                |
| :------- | :----------------------------- | ------------------------------------------ |
| 运行环境 | JVM（跨平台）                  | 编译为本地机器码（跨平台，依赖二进制）     |
| 语法风格 | 面向对象，语法较繁琐           | 简洁、易读，面向过程为主，支持简单面向对象 |
| 并发支持 | 多线程，依赖JVM线程模型        | 原生goroutine（轻量级线程），channel通信   |
| 执行效率 | 启动慢，JIT优化后运行效率高    | 编译后启动快，运行效率高，延迟低           |
| 内存管理 | 自动GC（垃圾回收），成熟但复杂 | 自动GC，延迟更低，GC简单                   |
| 泛型支持 | JDK1.5后支持泛型               | 1.18版本后支持泛型，之前无泛型             |
| 依赖管理 | Maven、Gradle等生态成熟        | Go Modules，简单直接                       |
| 构建部署 | 需JRE/JDK环境，部署包大        | 生成单一二进制文件，部署方便               |
| 库和生态 | 丰富、成熟、文档多、社区活跃   | 现代、增长快，云原生、微服务库多           |
| 错误处理 | 异常机制（try-catch）          | error值返回，显式处理，减少隐藏错误        |
| 跨平台   | 写一次到处运行，依赖JVM        | 编译为各平台二进制，跨平台简单             |
| 适合新人 | 学习曲线相对陡峭，体系庞大     | 语法简单，容易上手                         |

- Java 优势场景：

  - 企业级应用、大型后台系统（如金融、电商、ERP等）
  - 高并发、高可靠性要求的系统
  - 需要丰富生态和框架支持（如Spring、Hibernate等）
  - 跨平台且对JVM有依赖的项目

- Go 优势场景：

  - 云原生、微服务、容器化应用（Kubernetes、Docker等多用Go编写）
  - 网络服务、高性能API网关、分布式系统
  - 需要高并发、低延迟的后台服务
  - 需要简单部署和运维的场合
  - 命令行工具、轻量级应用